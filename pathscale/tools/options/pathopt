#!/usr/bin/python

#
# Copyright 2004, 2005, 2006 PathScale, Inc.  All Rights Reserved.
#
# Unpublished -- rights reserved under the copyright laws of the
# United States. USE OF A COPYRIGHT NOTICE DOES NOT IMPLY PUBLICATION
# OR DISCLOSURE. THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND
# TRADE SECRETS OF PATHSCALE, INC. USE, DISCLOSURE, OR REPRODUCTION IS
# PROHIBITED WITHOUT THE PRIOR EXPRESS WRITTEN PERMISSION OF
# PATHSCALE, INC.
#
# U.S. Government Restricted Rights:
# The Software is a "commercial item," as that term is defined at 48
# C.F.R. 2.101 (OCT 1995), consisting of "commercial computer
# software" and "commercial computer software documentation," as such
# terms are used in 48 C.F.R. 12.212 (SEPT 1995).  Consistent with 48
# C.F.R. 12.212 and 48 C.F.R. 227-7202-1 through 227-7202-4 (JUNE
# 1995), all U.S. Government End Users acquire the Software with only
# those rights set forth in the accompanying license
# agreement.
#
# PathScale, Inc. 2071 Stierlin Court, Suite 200; Mountain View CA 94043.

'''This script takes a file describing a set of options and compiles
and runs a program using variations of the options.  A sorted list
of runtimes is presented at the end.
'''

__author__ = "David Allison <dallison@pathscale.com>"


version = "1.4"

import os
import dispatcher
import time
import tempfile
import xml
import sys
import random


def find_compat_dir():
    def_path = '/opt/pathscale/bin'
    path = os.getenv('PATH').split(os.pathsep)
    if def_path not in path:
        path.append(def_path)
    for p in path:
        if os.access(os.path.join(p, 'pathcc'), os.X_OK):
            real = os.path.realpath(os.path.join(p, '../compat-gcc/bin'))
            if os.access(os.path.join(real, 'gcc'), os.X_OK):
                return real
    print >> sys.stderr, 'Could not find pathcc in your PATH'
    sys.exit(1)

wrapper_path = find_compat_dir()

class Result:
    def __init__ (self, time, options):
        self.time = time
        self.options = options

    def show(self, logfile):
        flagstring = ''
        for flag in self.options:
            flagstring += flag + ' '
        print "%-15g %-30s" % (self.time, flagstring)
        if logfile != None:
            print >>logfile, "%-15g %-30s" % (self.time, flagstring)

def resultcompare (a,b):
    return cmp (a.time, b.time)

results = []

cputime = False

buildscript = './psc_build'
testscript = './psc_test'

class Experiment:
    def __init__ (self, flags, squishflags):
        self.flags = flags
        self.squishflags = squishflags
        self.tmp = os.getcwd() + '/pscbuild/' + tempfile.mktemp()
        self.timeresult = os.getcwd() + '/pscbuild/' + tempfile.mktemp()
        os.makedirs (self.tmp)

        # messy!
        self.IDLE = 0
        self.RUNNING = 1
        self.TESTING = 2
        self.state = self.IDLE

    def run (self):
        flagstring = ''
        for flag in self.flags:
            flagstring += flag + ' '
        self.state = self.RUNNING
        env = {
            'PSC_GENFLAGS': flagstring,
            'PSC_SQUISHFLAGS': self.squishflags,
            'PATH': wrapper_path + os.pathsep + os.getenv('PATH')
            }
        dispatcher.dispatcher.putCommand (buildscript + ' ' + self.tmp, self,
                                          'Building: ' + flagstring, env)

    def test (self):
        oldpath = os.getenv ('PATH')
        self.state = self.TESTING
        env = {
            'TIME': '%U',
            'PATH': wrapper_path + os.pathsep + oldpath
            }
        self.starttime = time.time()
        dispatcher.dispatcher.putCommand (
            testscript + ' ' + self.tmp + ' ' + self.timeresult, self, 'Testing',
            env)

    def commandComplete (self, status):
        if os.WIFEXITED(status):
            flagstring = ''
            for flag in self.flags:
                flagstring += flag + ' '
            if os.WEXITSTATUS(status) != 0:
                print >> sys.stderr, 'Command exited with status %d, so the result for \'%s\' will not be recorded' % (os.WEXITSTATUS(status), flagstring)
                return
        else:
            print >> sys.stderr, 'Command exited with unknown status, so the result for \'%s\' not be recorded' % (flagstring)
            return
        global results
        # why is there no switch statement???
        if self.state == self.RUNNING:
            self.test()
        elif self.state == self.TESTING:
            endtime = 0.0
            if cputime:
                file = open (self.timeresult, 'r')
                line = file.read(100)
                file.close()
                self.starttime = 0.0
                endtime = float(line)
            else:
                endtime = time.time()
            duration = endtime - self.starttime
            self.state = self.IDLE
            result = Result (duration, self.flags)
            results.append (result)
            result.show(None)
            os.system ('rm -fr ' + self.tmp)
            os.system ('rm -fr ' + self.timeresult)
        else:
           raise Exception, 'Got command completion in IDLE state'

optfile = ''
nthreads = 1
nolog = False

def usage():
        print >>sys.stderr, 'usage: options [-version] [-cpu] -opt <file> [-nt nthreads] [-build buildscript] [-test testscript]'
        sys.exit (1)

def banner():
    print "PathOpt version %s" % version
    print "Copyright 2004, 2005, 2006 PathScale, Inc.  All Rights Reserved."
    print ""


i = 1
while i < len(sys.argv):
    if sys.argv[i] == "-opt":
        optfile = sys.argv[i+1]
        i += 1
    elif sys.argv[i] == "-version":
        banner()
        sys.exit(0)
    elif sys.argv[i] == "-cpu":
        cputime = True
    elif sys.argv[i] == '-nt':
        nthreads = int(sys.argv[i+1])
        i += 1
    elif sys.argv[i] == '-build':
        buildscript = sys.argv[i+1]
        i += 1
    elif sys.argv[i] == '-test':
        testscript = sys.argv[i+1]
        i += 1
    elif sys.argv[i] == '-nolog':
        nolog = True
    else:
        print 'pathopt: unknown option: ' + sys.argv[i]
        usage()
    i += 1

if optfile == '':
    usage()

banner()

dispatcher.startDispatcher (nthreads, False)

file = open (optfile, "r")
data = xml.parseStream (file)
file.close()

def get_squish (option):
    squishattr = option.findAttribute ('squish')
    squish = ''
    if squishattr != None:
        squish = squishattr.value
    return squish

def run_experiments (option, optionset):
    try:
        name = option.getAttribute ('name')
        optionset = optionset + [name]
    except:
        pass
    if option.name != 'dummy':
        experiment = Experiment (optionset, get_squish (option))
        experiment.run()

    for suboption in option.children:
        if suboption.name == 'option':
            run_experiments (suboption, optionset)
        elif suboption.name == 'optionlist':
            modeattr = suboption.findAttribute ('mode')
            mode = 'all'
            list = suboption.getAttribute ('list')
            if modeattr != None:
                mode = modeattr.value
            if mode == 'all':
                run_experiments (suboption, optionset + [list])
            elif mode == 'oneof':
                for opt in list.split():
                    run_experiments (suboption, optionset + [opt])
            elif mode == 'cummulative':
                all = list.split()
                newset = optionset
                for i in range(len(all)):
                    newset = newset + [all[i]]
                    run_experiments (suboption, newset)
            elif mode == 'progressive':
                all = list.split()
                for i in range (len(all) - 1, -1, -1):
                    newset = optionset
                    for j in range (i, len(all)):
                        newset = newset + [all[j]]
                        run_experiments (suboption, newset)
            elif mode == 'allbutoneof':
                all = list.split()
                for i in range (0, len(all)):
                    newset = optionset
                    for j in range(0, len(all)):
                        if i != j :
                            newset = newset + [all[j]]
                    run_experiments (suboption, newset)
            elif mode == 'random':
                all = list.split()
                iterattr = suboption.findAttribute ('iterations')
                iterations = 100
                if iterattr != None:
                    iterations = int(iterattr.value)
                for i in range (iterations):
                    newset = optionset
                    for j in range (len(all)):
                        if random.randint(0,1):
                             newset = newset + [all[j]]
                    run_experiments (suboption, newset)
            elif mode == 'exhaustive':
                all = list.split()

                for i in range (2**len(all)):
                    newset = optionset
                    for j in range (len(all)):             # bit number
                        if (i & (1<<j)) != 0:
                             newset = newset + [all[j]]
                    run_experiments (suboption, newset)

        else:
            print 'unknown option tag:', suboption.name

optset = data.find ('optionset')
for option in optset.children:
    if option.name == 'optionlist':
        # create dummy element with this as child
        dummy = xml.Element('dummy')
        dummy.addChild (option)
        run_experiments (dummy, [])
    else:
        run_experiments (option, [])

while not dispatcher.dispatcher.complete():
    time.sleep (1)

results.sort (resultcompare)


logfilename = 'pathopt.log.' + time.strftime ("%F.%H:%M:%S", time.localtime())
logfile = None
if not nolog:
    logfile = open (logfilename, "w")
    print >> logfile, "PathOpt results for experiments run on %s\n" % time.strftime ("%F %H:%M:%S", time.localtime())

print ''
print 'Results'
for result in results:
    result.show(logfile)

if not nolog:
    logfile.close()
    print ''
    print 'These results are logged in ' + logfilename

